<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库复习</title>
      <link href="/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>说鸽就鸽，亦是一种不鸽。</p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><p>这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。</p><p>关系型数据库以行(row)和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table)，一组表组成了一个库(database)。</p><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。</p><p>SQL 就是关系型数据库的查询语言。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>复杂查询<br>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p><p>事务支持<br>使得对于安全性能很高的数据访问要求得以实现。</p><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>非关系型数据库，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。同时，通过减少不常用的功能，进一步提高性能。</p><p>目前基本上大部分主流的非关系型数据库都是免费的。</p><h3 id="有哪些非关系型数据库"><a href="#有哪些非关系型数据库" class="headerlink" title="有哪些非关系型数据库"></a>有哪些非关系型数据库</h3><p>相比于SQL，NoSQL 泛指非关系数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。</p><h4 id="键值型数据库"><a href="#键值型数据库" class="headerlink" title="键值型数据库"></a>键值型数据库</h4><p>键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p><p>键值型数据库典型的使用场景是作为内存缓存。Redis 是最流行的键值型数据库。</p><h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><p>此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。</p><h4 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h4><p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p><h4 id="图形数据库"><a href="#图形数据库" class="headerlink" title="图形数据库"></a>图形数据库</h4><p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p><p>图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p><h2 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h2><h3 id="sql-sever的概述"><a href="#sql-sever的概述" class="headerlink" title="sql sever的概述"></a>sql sever的概述</h3><p>SQL Server 是Microsoft 公司推出的关系型数据库管理系统。具有使用方便可伸缩性好与相关软件集成程度高等优点，可跨越从运行Microsoft Windows 98 的小型电脑到运行Microsoft Windows 2012 的大型多处理器的服务器等多种平台使用。</p><p>Microsoft SQL Server 是一个全面的数据库平台，使用集成的商业智能 (BI)工具提供了企业级的数据管理。Microsoft SQL Server 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能，使您可以构建和管理用于业务的高可用和高性能的数据应用程序。</p><p>SQL Server 是一个关系数据库管理系统。它最初是由Microsoft、Sybase 和Ashton-Tate三家公司共同开发的，于1988 年推出了第一个OS&#x2F;2版本。在Windows NT 推出后，Microsoft与Sybase 在SQL Server 的开发上就分道扬镳了，Microsoft 将SQL Server移植到Windows NT系统上，专注于开发推广SQL Server 的Windows NT 版本。Sybase 则较专注于SQL Server在UNⅨ操作系统上的应用。</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h4 id="界面方式"><a href="#界面方式" class="headerlink" title="界面方式"></a>界面方式</h4><p> 在数据库项，右键“新建数据库”，然后在弹出窗口中输入数据库名称“TEST0”，然后点击确定即可。</p><h4 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h4><p>  使用命令行的方式创建一个名字为“TEST1”的数据库，同时需要明确指定TEST1的数据文件和日志文件所储存的路径和大小等信息。<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  CREATE DATABASE TEST1</span><br><span class="line">ON</span><br><span class="line">(</span><br><span class="line">NAME=<span class="string">&#x27;TEST1_DATA&#x27;</span>,</span><br><span class="line">FILENAME=<span class="string">&#x27;C:\Users\TEST1_DATA.MDF&#x27;</span>,</span><br><span class="line">SIZE=5MB,</span><br><span class="line">MAXSIZE=UNLIMITED,</span><br><span class="line">FILEGROWTH=10%</span><br><span class="line">)</span><br><span class="line">LOG ON</span><br><span class="line">(</span><br><span class="line">NAME=<span class="string">&#x27;TEST1_LOG&#x27;</span>,</span><br><span class="line">FILENAME=<span class="string">&#x27;C:\Users\TEST1_LOG.LDF&#x27;</span>,</span><br><span class="line">SIZE=5MB,</span><br><span class="line">MAXSIZE=50MB,</span><br><span class="line">FILEGROWTH=1MB</span><br><span class="line">)</span><br><span class="line">GO</span><br></pre></td></tr></table></figure></p><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><h4 id="界面方式-1"><a href="#界面方式-1" class="headerlink" title="界面方式"></a>界面方式</h4><p>在“TESTO”数据库右键找到“属性”项，在弹出窗口中选择“文件”项，就可以对数据进行修改。</p><h4 id="命令方式-1"><a href="#命令方式-1" class="headerlink" title="命令方式"></a>命令方式</h4><p>使用“ALTER DATABASE”命令对数据库可进行以下修改：</p><p>改变数据文件的大小和增长方式<br>改变日志文件的大小和增长方式<br>增加或删除日志文件<br>增加或删除数据文件<br>增加或删除文件组</p><h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE database_name</span><br><span class="line">&#123;ADD FILE &lt;filespec&gt;[,…n][ TO FILEGROUP filegroup_name ]/*在文件组中增加数据文件*/</span><br><span class="line"></span><br><span class="line">| ADD LOG FILE &lt;filespec&gt;[,…n]           /*增加日志文件*/</span><br><span class="line"></span><br><span class="line">| REMOVE FILE logical_file_name           /*删除数据文件*/</span><br><span class="line"></span><br><span class="line">| ADD FILEGROUP filegroup_name          /*增加文件组*/</span><br><span class="line"></span><br><span class="line">| REMOVE FILEGROUP filegroup_name      /*删除文件组*/</span><br><span class="line"></span><br><span class="line">| MODIFY FILE &lt;filespec&gt;                 /*更改文件属性*/</span><br><span class="line"></span><br><span class="line">| MODIFY NAME = new_dbname           /*数据库更名*/</span><br><span class="line"></span><br><span class="line">| MODIFY FILEGROUP filegroup_name &#123;filegroup_property | NAME = new_filegroup_name &#125;</span><br><span class="line"></span><br><span class="line">| SET &lt;optionspec&gt; [ ,...n ] [ WITH &lt;termination&gt; ]   /*设置数据库属性*/</span><br><span class="line"></span><br><span class="line">| COLLATE &lt; collation_name &gt; /*指定数据库排序规则*/</span><br><span class="line">&#125;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h5 id="演示前提"><a href="#演示前提" class="headerlink" title="演示前提:"></a>演示前提:</h5><p>假设已经创建了数据库TEST1，它只有一个主数据文件，其逻辑文件名为TEST1_DATA，大小为5MB，最大为50MB，增长方式为按10%增长。</p><h5 id="案例演示1："><a href="#案例演示1：" class="headerlink" title="案例演示1："></a>案例演示1：</h5><p>修改数据库TEST1现有数据文件的属性，将主数据文件的最大大小改为100MB，增长方式改为按每次5MB增长。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE TEST1</span><br><span class="line">MODIFY FILE </span><br><span class="line">(</span><br><span class="line">NAME = TEST1_DATA,  --这里是逻辑名</span><br><span class="line">MAXSIZE = 100MB,--将主数据文件的最大大小改为100MB</span><br><span class="line">FILEGROWTH = 5MB--将主数据文件的增长方式改为按5MB增长</span><br><span class="line">)</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h5 id="案例演示2"><a href="#案例演示2" class="headerlink" title="案例演示2"></a>案例演示2</h5><p>为数据库TEST1添加文件组FGROUP，并为此文件组添加两个大小均为10MB的数据文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE TEST1</span><br><span class="line">ADD FILEGROUP FGROUP  --新增文件组的名字</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">ALTER DATABASE TEST1</span><br><span class="line">ADD FILE</span><br><span class="line">(</span><br><span class="line">NAME = <span class="string">&#x27;TEST1_DATA2&#x27;</span>,</span><br><span class="line">FILENAME = <span class="string">&#x27;C:\Users\TEST1_DATA2.ndf&#x27;</span>,</span><br><span class="line">SIZE = 10MB,</span><br><span class="line">MAXSIZE = 30MB,</span><br><span class="line">FILEGROWTH = 5MB</span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line">NAME = <span class="string">&#x27;TEST1_DATA3&#x27;</span>,</span><br><span class="line">FILENAME = <span class="string">&#x27;C:\Users\TEST1_DATA3.ndf&#x27;</span>,</span><br><span class="line">SIZE = 10MB,</span><br><span class="line">MAXSIZE = 30MB,</span><br><span class="line">FILEGROWTH = 5MB</span><br><span class="line">)</span><br><span class="line">TO FILEGROUP FGROUP  --添加到指定文件组</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h5 id="案例演示3"><a href="#案例演示3" class="headerlink" title="案例演示3"></a>案例演示3</h5><p>从数据库TEST1中删除一个日志文件，将日志文件TEST1_LOG2删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE TEST1</span><br><span class="line">REMOVE FILE TEST1_LOG2</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h5 id="案例演示4"><a href="#案例演示4" class="headerlink" title="案例演示4"></a>案例演示4</h5><p>将数据库TEST1的名改为JUST_TEST，进行此操作时必须保证该数据库不被其他任何用户使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE TEST1</span><br><span class="line">MODIFY NAME = JUST_TEST</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h3 id="数据库删除"><a href="#数据库删除" class="headerlink" title="数据库删除"></a>数据库删除</h3><h4 id="界面方式-2"><a href="#界面方式-2" class="headerlink" title="界面方式"></a>界面方式</h4><p>在要删除数据库上右键选择“删除”，在弹出窗口中选择确定即可删除当前数据库</p><h4 id="命令方式-2"><a href="#命令方式-2" class="headerlink" title="命令方式"></a>命令方式</h4><p>删除数据库使用“DROP DATABASE”命令。</p><p>语法格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE database_name[,…n][;]</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p>删除JUST_TEST数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE JUST_TEST</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="SQL-Server数据的类型"><a href="#SQL-Server数据的类型" class="headerlink" title="SQL Server数据的类型"></a>SQL Server数据的类型</h2><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><p>整数包括bigint、int、smallint和tinyint，从标识符的含义就可以看出，它们所表示的数范围逐渐缩小。</p><p>bigint：大整数，数范围为-263（-9223372036854775808）～263-1（9223372036854775807），长度为8字节。</p><p>int：整数，数范围为-231（-2147483648）～231-1（2147483647），长度为4字节。</p><p>smallint：短整数，数范围为-215（-32768）～215-1（32767），长度为2字节。</p><p>tinyint：微短整数，数范围为 0～255，长度为1字节。</p><h3 id="精确数值型"><a href="#精确数值型" class="headerlink" title="精确数值型"></a>精确数值型</h3><p>精确数值型包括decimal和numeric，他们可存储从-1038+1到1038-1的数字数据。</p><p>它们的存储长度随精度（位数）变化而变化，最少为5字节，最多为17字节：</p><pre><code>精度为1～9时，存储字节长度为5。精度为10～19时，存储字节长度为9。精度为20～28时，存储字节长度为13。精度为29～38时，存储字节长度为17。</code></pre><p>例如，若有声明numeric(8,3)，则存储该类型数据需5字节；而若有声明numeric(22,5)，则存储该类型数据需13字节。</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>  浮点型包括real和float[（n）]。两者通常都使用科学计数法表示数据，即形为：位数E阶数，如5.6432E20、-2.98E10、1.287659E-9等。</p><pre><code>real：使用4字节存储数据，表数范围为-3.40E+38～3.40E+38，数据精度为7位有效数字。float[(n)] ：表数范围为-1.79E+308～1.79E+308。定义中的n取值范围是1～53，用于指示其精度和存储大小。当n在1～24之间时，实际上是定义了一个real型数据，存储长度为4字节，精度为7位有效数字。当n在25～53之间时，存储长度为8字节，精度为15位有效数字。当缺省n时，代表n在25～53之间。</code></pre><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符型用于存储字符串，在输入字符串时，需将串中的符号用单引号括起来，如‘abc’。</p><p>字符型包括两类：char是固定长度的数据类型，varchar是可变长度的数据类型，二者均使用ASCII字符集。</p><p> char[(n)]：定长字符数据类型，其中n在1到8000之间，缺省为1。当实际存储的串长度不足n时，则在串的尾部添加空格。</p><p>varchar[(n)]：变长字符数据类型，这里n表示的是字符串可达到的最大长度。</p><h3 id="Unicode字符型"><a href="#Unicode字符型" class="headerlink" title="Unicode字符型"></a>Unicode字符型</h3><p>Unicode是“统一字符编码标准”，用于支持国际上非英语语种的字符数据的存储和处理，包括nchar[(n)]和nvarchar[(n)] 。</p><p>Unicode字符型包括两类：nchar是固定长度的数据类型，nvarchar是可变长度的数据类型，二者均使用UNICODE UCS-2字符集。</p><p>nchar[(n)]：n的值在1与4000之间，缺省为1，长度2n字节。若输入的字符串长度不足n，将以空白字符补足。</p><p>nvarchar[(n)]：nvarchar[(n)]为最多包含n个字符的可变长度Unicode字符型数据，n的值在1与4000之间，缺省为1。长度是所输入字符个数的两倍。</p><p>实际上，nchar、nvarchar与char、varchar的使用非常相似，只是字符集不同（前者使用Unicode字符集，后者使用ASCII字符集）。</p><h3 id="二进制型"><a href="#二进制型" class="headerlink" title="二进制型"></a>二进制型</h3><p>二进制数据类型表示的是位数据流，包括binary（固定长度）和varbinary（可变长度）两种。</p><p> binary [(n)]：固定长度的n个字节二进制数据。n取值范围为1到8000，缺省为1。</p><p> varbinary [(n)]：n个字节变长二进制数据。n取值范围为1到8000，缺省为1。</p><h2 id="SQL-Server数据表管理"><a href="#SQL-Server数据表管理" class="headerlink" title="SQL Server数据表管理"></a>SQL Server数据表管理</h2><p>首先先创建一个数据库，名字叫”学生信息数据库”，以下操作均在改数据库中进行。</p><h3 id="新建数据表"><a href="#新建数据表" class="headerlink" title="新建数据表"></a>新建数据表</h3><p>学生表的表结构：</p><p>列 名数 据 类 型      长度 可空默认值   说 明<br>学号定长字符型（char）6×无   主键，2位年级，2位班号，2位序号<br>姓名定长字符型（char）8×无<br>性别位型（bit）        1√1    1：男；0：女<br>出生时间 日期型（datetime）系统默认 √ 无<br>专业定长字符型（char）12√无<br>总学分整数型（int）   4√0        0≤总学分&lt;160<br>备注变长字符型（varchar）500√无</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE XSB (</span><br><span class="line">    学号 char(<span class="number">6</span>) NOT NULL ,</span><br><span class="line">    姓名 char(<span class="number">8</span>) NOT NULL ,</span><br><span class="line">    性别 bit NULL DEFAULT (<span class="number">1</span>) ,</span><br><span class="line">    出生时间 datetime NULL ,</span><br><span class="line">    专业 char(<span class="number">12</span>) NULL ,</span><br><span class="line">    总学分 <span class="built_in">int</span> NULL DEFAULT (<span class="number">0</span>) CHECK (总学分&gt;=<span class="number">0</span> AND 总学分&lt;<span class="number">160</span>) ,</span><br><span class="line">    备注 varchar(<span class="number">500</span>) NULL ,</span><br><span class="line">    PRIMARY KEY (学号)</span><br><span class="line">)</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>课程表的表结构</p><p>列 名数 据 类 型长 度可 空默 认 值说 明<br>课程号定长字符型（char）3×无主键<br>课程名定长字符型（char）16×无<br>开课学期整数型（tinyint）1√1只能为1～8<br>学时整数型（tinyint）1√0<br>学分整数型（tinyint）1×0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE KCB (</span><br><span class="line">    课程号 char(3) NOT NULL ,</span><br><span class="line">    课程名 char(16) NULL ,</span><br><span class="line">    开课学期 tinyint NULL DEFAULT (1) CHECK (开课学期&gt;=1 AND 开课学期&lt;=8) ,</span><br><span class="line">    学时 tinyint NULL DEFAULT (0) ,</span><br><span class="line">    学分 tinyint NULL DEFAULT (0) ,</span><br><span class="line">    PRIMARY KEY (课程号)</span><br><span class="line">)</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>成绩表的表结构</p><p>列 名数 据 类 型     长度 可空 默认值说明<br>学号定长字符型（char）6×无主键<br>课程号定长字符型（char）3×无主键<br>成绩整数型（int）默认值√0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE CJB (</span><br><span class="line">    学号 char(6) NOT NULL ,</span><br><span class="line">    课程号 char(3) NOT NULL ,</span><br><span class="line">    成绩 int NULL DEFAULT (0) ,</span><br><span class="line">    PRIMARY KEY (学号, 课程号)</span><br><span class="line">)</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h3 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h3><p>添加一列：在学生表中增加1个新列一奖学金等级，类型为tinyint，允许为null</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table XSB</span><br><span class="line">add 奖学金等级 tinyint NULL</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>修改一列：修改学生表中奖学金等级列的类型，类型为int，不允许为null</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table XSB</span><br><span class="line">     alter colum 奖学金等级 int NOT NULL</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>删除一列:删除XSB表中奖学金等级这一个列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table XSB</span><br><span class="line">    drop  column 奖学金等级</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p>删除学生表：<br>drop table XSB<br>GO</p><p>删除课程表:<br>drop table KCB<br>GO</p><h2 id="SQL-Server表数据管理"><a href="#SQL-Server表数据管理" class="headerlink" title="SQL Server表数据管理"></a>SQL Server表数据管理</h2><p>首先创建一个数据表，名字叫“XSB”，以下操作均在该数据表中进行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸进程的创建和杀死</title>
      <link href="/2022/11/03/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/11/03/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>感谢李世斌老师，感谢肖志恒老师，感谢郭晓婉老师提供的指导与帮助。</p><h3 id="vim和gss的下载"><a href="#vim和gss的下载" class="headerlink" title="vim和gss的下载"></a>vim和gss的下载</h3><p>基于Linux系统下的vim和gcc安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim</span><br><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure><p>输入命令查看gcc是否安装完成，安装完成后会显示版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><h3 id="创建一个-c文件"><a href="#创建一个-c文件" class="headerlink" title="创建一个.c文件"></a>创建一个.c文件</h3><p>在终端输入命令创建c语言文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim xxx.c</span><br></pre></td></tr></table></figure><p>进入编译<br>输入僵尸进程的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">pid_t childpid;</span><br><span class="line">int status;</span><br><span class="line">int retval;</span><br><span class="line">childpid=fork();</span><br><span class="line"><span class="keyword">if</span>(-1==childpid)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(0==childpid)</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">&quot;In child process&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child process ID=%d,this process will sleep 100s\n&quot;</span>,(int) getpid());</span><br><span class="line"><span class="built_in">sleep</span>(100);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent process ID=%d, prarent process will do waitpid\n&quot;</span>,(int)getpid());</span><br><span class="line"><span class="keyword">if</span>(0==(waitpid(childpid,&amp;status,WNOHANG)))</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;kill the active child process\n&quot;</span>);</span><br><span class="line"> retval=<span class="built_in">kill</span>(childpid,SIGKILL);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;parent killed child process\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(retval)</span><br><span class="line"> &#123;</span><br><span class="line"> puts(<span class="string">&quot;kill failed.&quot;</span>);</span><br><span class="line"> perror(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line"> waitpid(childpid,&amp;status,0);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d was killed \n&quot;</span>,childpid);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;current active process after killed child process \n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结束后退出：</p><p>方式一：按下esc键，输入“:wq”3个英文字符，然后按下Enter键，表示保存文件并退出。</p><p>方式二：按下esc键，输入“:q”两个英文字符，然后按下Enter键，表示不保存并退出。（如果本次编辑没有修改内容，则可以顺利退出；否则，vim编辑器是不会允许你退出的，这时如果想要不保存退出，就要使用下面的方法三）</p><p>方式三：按下esc键，输入“:q!”3个英文字符，然后按Enter键，表示不保存并强制退出。</p><h3 id="利用gcc编译文件"><a href="#利用gcc编译文件" class="headerlink" title="利用gcc编译文件"></a>利用gcc编译文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c - o xxx  （xxx为你设置的文件名）</span><br></pre></td></tr></table></figure><h3 id="编译结束后运行文件"><a href="#编译结束后运行文件" class="headerlink" title="编译结束后运行文件"></a>编译结束后运行文件</h3><p>输入命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx   （xxx为你的设置文件名）</span><br></pre></td></tr></table></figure><h3 id="查看僵尸进程pid号"><a href="#查看僵尸进程pid号" class="headerlink" title="查看僵尸进程pid号"></a>查看僵尸进程pid号</h3><p>输入命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep defunct</span><br></pre></td></tr></table></figure><img src="/img/z1.jpg "> <h3 id="利用top查看僵尸进程"><a href="#利用top查看僵尸进程" class="headerlink" title="利用top查看僵尸进程"></a>利用top查看僵尸进程</h3><p>输入命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>如果不出意外，你的页面右上角zombie数量为1 证明僵尸进程存在<br><img src="/img/z2.jpg "> </p><p>如果出了意外，请跳转到文章结尾。</p><p>下一步就到了杀死僵尸进程的时候了！</p><h3 id="如何杀死僵尸进程"><a href="#如何杀死僵尸进程" class="headerlink" title="如何杀死僵尸进程"></a>如何杀死僵尸进程</h3><p>一般僵尸进程很难直接kill掉，不过您可以kill父进程(僵尸父亲)，“父亲”死后，僵尸进程成为”孤儿进程”，接着给init它始终会负责清理僵尸进程．紧随着父亲消失了，儿子也就跟着消失了。</p><h4 id="ps-命令和-grep命令寻找僵尸进程"><a href="#ps-命令和-grep命令寻找僵尸进程" class="headerlink" title="ps 命令和 grep命令寻找僵尸进程"></a>ps 命令和 grep命令寻找僵尸进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -ostat,ppid,pid,cmd | grep -e <span class="string">&#x27;^[Zz]&#x27;</span></span><br></pre></td></tr></table></figure><img src="/img/z3.jpg "> <p>记住你的僵尸pid号</p><h4 id="使用kill命令杀死僵尸进程"><a href="#使用kill命令杀死僵尸进程" class="headerlink" title="使用kill命令杀死僵尸进程"></a>使用kill命令杀死僵尸进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程pid号</span><br></pre></td></tr></table></figure><p>运行结束后可以再次输入top查看进程是否被杀死<br><img src="/img/z4.png "> </p><h3 id="已经编译运行完成为什么zombie数量为0"><a href="#已经编译运行完成为什么zombie数量为0" class="headerlink" title="已经编译运行完成为什么zombie数量为0"></a>已经编译运行完成为什么zombie数量为0</h3><p>此方法来自李世斌老师在某天打完游戏后想出来的野路子。<br>.&#x2F;xxx  运行结束后 直接ctrl+z 再查看top</p><p>输入.&#x2F;之后，子进程正在执行，还没执行到杀死僵尸进程那一步，直接ctrl+z强制退出，所以还没执行到那一步，这个时候查看应该能看到。</p><p>更正规的方法是修改代码，此条解决方案来自肖志恒老师。<br>将倒数第三行的 getchar();删掉，在杀死子进程的那个父进程前面加个sleep。具体等肖老师研究了再说说。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大摆特摆</title>
      <link href="/2022/10/26/%E5%94%A0%E5%94%A0%E5%8F%A8%E5%8F%A8/"/>
      <url>/2022/10/26/%E5%94%A0%E5%94%A0%E5%8F%A8%E5%8F%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="2022年10月26日"><a href="#2022年10月26日" class="headerlink" title="2022年10月26日"></a>2022年10月26日</h2><p>  安装图床失败有感而发呜呜呜呜。这个事情告诉我们，有时候努力不如摆烂。开心的席师傅在配置好gitee的图床的时候，发现它不能用了呜呜呜嘿嘿嘿呜呜呜<br>  事实证明，精神状态差了，人就开心了。<br>  我想了一夜，我都不知道为什么我的token不能用为什么github不能用，为什么别人的界面甚至和我的长得都不一样，紫砂，这个博客里面不会出现照片了。<br>  MS.SM什么垃圾网站都打不开。<br>  因为席师傅安装不好图呜呜呜呜，以后有钱了，再说租服务器的事情。<br>  罢了，人生就是这样，大肠包小肠，小肠包大肠。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课后题</title>
      <link href="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>  操作系统老师布置的一些课后题</p><h2 id="第三章：处理机调度与死锁"><a href="#第三章：处理机调度与死锁" class="headerlink" title="第三章：处理机调度与死锁"></a>第三章：处理机调度与死锁</h2><h3 id="高级调度与低级调度的主要任务是什么-为什么要引入中级调度"><a href="#高级调度与低级调度的主要任务是什么-为什么要引入中级调度" class="headerlink" title="高级调度与低级调度的主要任务是什么? 为什么要引入中级调度?"></a>高级调度与低级调度的主要任务是什么? 为什么要引入中级调度?</h3><p> 高级调度的主要任务：用于决定把外存上处于后背队列中的哪些作业调入内存，并为它们创建进程，分配必要的资源，再将新创建的进程插入就绪队列上，准备执行。低级调度的主要任务：用于决定就绪队列中的哪个进程获得处理机，然后再由分派程序执行将处理机分配给该进程的具体操作。</p><h3 id="引起进程调度的原因"><a href="#引起进程调度的原因" class="headerlink" title="引起进程调度的原因"></a>引起进程调度的原因</h3><p>在不可剥夺方式下的引起进程调度的原因：</p><p>　(1)正在执行的进程执行完毕。这时，如果不选择新的就绪进程执行，将浪费处理机资源。</p><p>　(2)执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等状态。</p><p>　(3)执行中进程调用了P原语操作，从而因资源不足而被阻塞；或调用了v原语操作激活了等待资源的进程队列。</p><p>　(4)执行中进程提出I&#x2F;O请求后被阻塞。</p><p>　(5)在分时系统中时间片已经用完。</p><p>　(6)在执行完系统调用等系统程序后返回用户进程时，这时可看作系统进程执行完毕，从而可调度选择一新的用户进程执行。</p><p>在CPU执行方式是可剥夺时．还有：</p><p>　(7)就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。</p><h3 id="什么是死锁-产生死锁的必要条件-怎样预防和避免死锁"><a href="#什么是死锁-产生死锁的必要条件-怎样预防和避免死锁" class="headerlink" title="什么是死锁? 产生死锁的必要条件?怎样预防和避免死锁?"></a>什么是死锁? 产生死锁的必要条件?怎样预防和避免死锁?</h3><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><p>当多个进程在运行过程中因为争夺资源而造成的一种僵局, 当进程处于这种僵持状态的时候, 若无外力作用, 它们将永远无法向前推进. 这种状态就称为死锁。</p><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><p>产生死锁总共有 4 个必要条件:</p><p>资源互斥: 当一个资源被一个进程使用时候, 其他继承不能使用该资源</p><p>资源不可剥夺: 进程已持有的资源在使用完之前是不可被剥夺的, 只能在使用完后由自己释放</p><p>请求和保持: 当进程在请求其他资源的时候, 对自己已持有的资源保持不放</p><p>循环等待: 即存在一个等待队列: 例如: A 占有 B 的资源, B 占有 C 的资源, C 占有 A 的资源, 这样就形成了一个等待环路。</p><p>当以上 4 个条件同时成立的时候, 就会产生死锁</p><h4 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h4><p>1.资源一次性分配(破坏请求条件): 一次性分配所有的资源, 这样就不会再有请求了</p><p>2.(破坏保持条件): 一个进程只要有一个资源得不到分配, 就也不给这个进程分配其他资源</p><p>3.可剥夺资源(破坏不可剥夺性): 一个进程即使获得了部分资源, 但是如果得不到其他资源, 就需要释放掉已有的资源</p><p>4.资源有序分配(破坏循环等待): 系统为每类资源分配一个编号, 每一个进程按照编号以递增的顺序请求资源, 释放则相反</p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>预防死锁的四种方法, 都会严重的影响系统性能. 因此可以尽可能去避免死锁的产生.<br>在避免死锁的策略中, 允许进程动态地申请资源. 所以, 系统在进行资源分配的时候, 会预先计算资源分配的安全性, 如果此次资源分配不会导致系统进入不安全的状态, 就将资源分配给进程, 否则, 进程等待。</p><p>补充：避免死锁的方法中最经典和最重要的就是: 银行家算法<br>原理:<br>将操作系统视为一个银行家, 将操作系统所管理的资源视为银行家的资金, 进程申请资源就视为用户向银行家贷款<br>当一个顾客对资金的最大需求量不超过银行家现有的资金时, 就可以接纳该顾客<br>顾客可以分期贷款, 但是贷款的总额不可以超过最大需求量<br>当银行家现有资金不能满足用户尚需的贷款金额时, 可以推迟支付贷款, 但是使顾客在有限的时间内拿到贷款<br>当顾客得到所有所需资金后, 一定可以在有限时间内归还所有的资金</p><h4 id="解除死锁的方法"><a href="#解除死锁的方法" class="headerlink" title="解除死锁的方法"></a>解除死锁的方法</h4><p> 剥夺资源: 从其他进程剥夺足够数量的资源给死锁, 用以解除死锁状态<br> 撤销进程: 撤销系统中一个或者多个死锁进程</p><h3 id="一个课后题链接"><a href="#一个课后题链接" class="headerlink" title="一个课后题链接"></a>一个课后题链接</h3><p> 还是白嫖好。<br> <a href="https://blog.csdn.net/m0_50629759/article/details/120927611?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%86%E4%B8%80%E7%BB%84%E8%BF%9B%E7%A8%8B%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB%EF%BC%8C%E5%A6%82%E5%9B%BE3-23%E6%89%80%E7%A4%BA&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120927611.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/m0_50629759/article/details/120927611?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%86%E4%B8%80%E7%BB%84%E8%BF%9B%E7%A8%8B%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB%EF%BC%8C%E5%A6%82%E5%9B%BE3-23%E6%89%80%E7%A4%BA&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120927611.nonecase&amp;spm=1018.2226.3001.4187</a></p><h3 id="设系统中有下述解决死锁的办法"><a href="#设系统中有下述解决死锁的办法" class="headerlink" title="设系统中有下述解决死锁的办法"></a>设系统中有下述解决死锁的办法</h3><p>(1)银行家算法。</p><p>(2)检测死锁，终止处于死锁状态的进程，释放该进程所占有的资源。</p><p>(3)资源预分配。</p><p>请问哪种办法允许最大的并发性，即哪种办法允许更多的进程无等待地向前推进?请按“并发性”从大到小对上述三种办法进行排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三种办法中，首先检测死锁允许更多的进程无等待地向前推进。因为该方法允许死锁出现，即允许进程最大限度地申请并分配资源，直至出现死锁，再由系统出面解决。</span><br><span class="line">其次是银行家算法，该方法允许进程自由申请资源，只是在某个进程申请时检查系统是否处于安全状态，若是，则可立即分配，若不是，才拒绝。</span><br><span class="line">最后是资源预分配，因为此方法要求进程在运行之前申请所需的全部资源才可开始运行，这样会使得许多进程因申请不到资源而无法开始，得到资源的进程也并不是同时需要所占的全部资源，因此导致资源的浪费。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java学习</title>
      <link href="/2022/10/21/java/"/>
      <url>/2022/10/21/java/</url>
      
        <content type="html"><![CDATA[<p>  关于java也没有好好学这件事情，真的已经麻了。到CSDN总结了点学习重点，主要是自己打一遍印象深。</p><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="案例常见问题"><a href="#案例常见问题" class="headerlink" title="案例常见问题"></a>案例常见问题</h3><p>1、非法字符问题。Java中的符号都是英文格式的。<br>2、大小写问题。Java语言对大小写敏感(区分大小写)。<br>3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。<br>4、编译命令后的java文件名需要带文件后缀.java<br>5、运行命令后的class文件名(类名)不带文件后缀.class …</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h3><p>单行注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这是单行注释文字</span><br></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  这是多行注释文字 这是多行注释文字 这是多行注释文字</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>多行注释不能嵌套使用</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是在程序运行过程中，其值不可以发生改变的量。</p><p>java中的常量分类</p><p>字符串常量 用双引号括起来的多个字符（可以包含0个，一个，或者多个），，例如”a”、“abc”、”中国”等<br>整数常量整数：-10、0、88等<br>小数常量整数：-5.5、1.0、88.88等<br>字符常量 用单引号括起来的一个字符 :’a’、’5’、’B’、’哈’等<br>布尔常量 布尔值，表示真假，只有两个值true和false<br>空常量 一个特殊的值 ，空值，为null<br>除空常量外，其他常量局可以使用输出语句直接输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println (10); //输出一个字符</span><br><span class="line">    System.out.println (5.5); //输出一个小数</span><br><span class="line">    System.out.println (‘a’)； //输出一个字符</span><br><span class="line">    System.out.println(<span class="literal">true</span>); // 输出boolean值<span class="literal">true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;毛毛摸猫猫&quot;</span>); // 输出字符串</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h3><p>我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位 (bit)”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节(byte)”，<br>通常用大写字母”B”表示，字节是由连续的8个位组成。<br>除了字节外还有一些常用的存储单位，其换算单位如下:<br>1B(字节) &#x3D; 8bit<br>1KB &#x3D; 1024B<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB<br>1TB &#x3D; 1024GB</p><h3 id="Java中的数据类型"><a href="#Java中的数据类型" class="headerlink" title="Java中的数据类型"></a>Java中的数据类型</h3><p>  java是一种强类型语言，java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。</p><h4 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h4><p>  整数类型的关键字：byte       内存占用：1 取值范围：-128到127<br>  整数类型的关键字：short      内存占用：2 取值范围：-32768到32767<br>  整数类型的关键字：int(默认)  内存占用：4 取值范围：-2的31次方到2的31次方-1<br>  整数类型的关键字：long       内存占用：8 取值范围：-2的63次方到2的63次方-1</p><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>  浮点类型的关键字：float       内训占用：4 取值范围：负数:-3.402823E+38到-1.401298E-45 正数: 1.401298E-45到 3.402823E+38<br>  浮点类型的关键字：double(默认) 内存占用：8 取值范围：负数:-1.797693E+308到-4.9000000E-324 正数:4.9000000E-324 到1.797693E+308</p><h4 id="字符类型和布尔类型"><a href="#字符类型和布尔类型" class="headerlink" title="字符类型和布尔类型"></a>字符类型和布尔类型</h4><p>  字符类型的关键字：char内存占用：2取值范围：0-65535<br>  布尔类型关键字：boolean内存占用：1取值范围：true，false</p><p>  说明: e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。在java中整数默认是int类型，浮点数默认是double类型。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><pre><code>在程序运行过程中，其值可以发生改变的量。从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。</code></pre><p>变量的定义格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：数据类型 变量名 = 变量值;</span><br><span class="line">范例：   int    a     = 10;</span><br></pre></td></tr></table></figure><p>数据类型 变量名&#x3D;初始化值；&#x2F;&#x2F;生命变量并赋值<br>int age &#x3D; 18；<br>System.out.println(age)</p><p>或者 </p><p>&#x2F;&#x2F;先声明，后赋值（使用前赋值即可）数据类型 变量名;<br>变量名&#x3D;初始化值;<br>double money;<br>money &#x3D; 55.5;<br>System.out.println(money);</p><p>还可以在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">int c,d; // 声明int类型的变量c和d，中间使用逗号隔开</span><br><span class="line">c = 30;</span><br><span class="line">d = 40;</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><h3 id="使用变量时的注意事项"><a href="#使用变量时的注意事项" class="headerlink" title="使用变量时的注意事项"></a>使用变量时的注意事项</h3><p>1.在统一对花括号中，变量名不能重复。<br>2.变量在使用之前，必须初始化（赋值）。<br>3.定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写。）因为整数默认是int类型，整数太大可能超过int范围。<br>4.定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写。）因为浮点数的默认类型是double，double的取值范围是大于float的，类型不兼容。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是用户编程时使用的名字，用于给类，方法，变量，常量等命名。<br>Java中标识符的组成规则:<br>由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。<br>不能使用java中的关键字作为标识符。<br>标识符对大小写敏感(区分大小写)。<br>Java中标识符的命名约定:<br>小驼峰式命名:变量名、方法名<br>首字母小写，从第二个单词开始每个单词的首字母大写。<br>大驼峰式命名:类名<br>每个单词的首字母都大写。<br>另外，标识符的命名最好可以做到见名知意<br>例如:username、studentNumber等。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。自动类型转换：<br>把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如</p><p>double num &#x3D; 10;&#x2F;&#x2F;将int类型的10直接复制给double类型<br>System.out.println(num);&#x2F;&#x2F;输出10.0</p><p>强制类型转换：<br>把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。<br>强制类型转换改革是：目标数据类型 变量名 &#x3D; （目标数据类型）值或者变量;<br>例如：</p><p>double num1 &#x3D; 5.5;<br>int num2 &#x3D; （int）num1;&#x2F;&#x2F;将double类型的num1强制转换为int类型<br>System.out.println(num2);输入5（小数位直接舍弃）</p><p>说明：<br>1.char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，’a’对应97</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于网络安全的常见用语缩写</title>
      <link href="/2022/10/20/%E5%B8%B8%E8%A7%81%E7%94%A8%E8%AF%AD/"/>
      <url>/2022/10/20/%E5%B8%B8%E8%A7%81%E7%94%A8%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>关于网络安全的一些常见用语和缩写</p><h2 id="亿点点知识补充"><a href="#亿点点知识补充" class="headerlink" title="亿点点知识补充"></a>亿点点知识补充</h2><h3 id="什么是EXP"><a href="#什么是EXP" class="headerlink" title="什么是EXP"></a>什么是EXP</h3><p>EXP全称（exploit）即利用，是指利用系统漏洞进行攻击的动作。</p><p>EXP，Exploit，中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。</p><h3 id="什么是Poc（Proof-of-Concept概念证明）"><a href="#什么是Poc（Proof-of-Concept概念证明）" class="headerlink" title="什么是Poc（Proof of Concept概念证明）"></a>什么是Poc（Proof of Concept概念证明）</h3><p>Poc是用来证明漏洞存在的。简单来说用来证明一段漏洞的代码，他是无害的。</p><h3 id="什么是payload"><a href="#什么是payload" class="headerlink" title="什么是payload"></a>什么是payload</h3><p>payload（有效荷载），指的是exploit执行成功之后，真正在系统进行执行的利用执行的代码或者指令。</p><p>payload是一种以JSON格式进行数据传输的一种方式。</p><p>http可能会传输payload，如果不限制其请求的方式(那么请求的方法就是OPTIONS)或者响应的状态码，其包含元数据，头部区域和数据。</p><p>如果数据是通过正常的put或者post方法发送的，那么payload就是一个http请求起始行紧接一个CRLF后面的那一部分。</p><p>Payload中包含攻击进入目标主机后需要在远程系统中运行的恶意代码，而在Metasploit中Payload是一种特殊模块，它们能够以漏洞利用模块运行，并能够利用目标系统中的安全漏洞实施攻击。简而言之，</p><h3 id="什么是shellcode"><a href="#什么是shellcode" class="headerlink" title="什么是shellcode"></a>什么是shellcode</h3><p>shellcode简单翻译就是shell代码，是payload的一种，他是因为建立正反shell而得名的。shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。</p><p>Shellcode是payload中的精髓部分，在渗透攻击时作为攻击载荷运行的一组机器指令。Shellcode通常用汇编语言编写。在大多数情况下，目标系统执行了shellcode这一组指令之后，才会提供一个命令行shell。</p><h3 id="什么是VUL"><a href="#什么是VUL" class="headerlink" title="什么是VUL"></a>什么是VUL</h3><p>  VUL，Vulnerability的缩写，泛指漏洞。</p><h3 id="CVE漏洞编号"><a href="#CVE漏洞编号" class="headerlink" title="CVE漏洞编号"></a>CVE漏洞编号</h3><p>CVE 的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露，例如CVE-2015-0057、CVE-1999-0001等等。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。如果在一个漏洞报告中指明的一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全问题。</p><h3 id="0DAY漏洞和0DAY攻击"><a href="#0DAY漏洞和0DAY攻击" class="headerlink" title="0DAY漏洞和0DAY攻击"></a>0DAY漏洞和0DAY攻击</h3><p>在计算机领域中，零日漏洞或零时差漏洞（英语：Zero-dayexploit）通常是指还没有补丁的安全漏洞，而零日攻击或零时差攻击（英语：Zero-dayattack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。零日漏洞的利用程序对网络安全具有巨大威胁，因此零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。</p><p>零日漏洞及其利用代码不仅对犯罪黑客而言，具有极高的利用价值，一些国家间谍和网军部队，例如美国国家安全局和美国网战司令部也非常重视这些信息。据路透社报告称美国政府是零日漏洞黑市的最大买家。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit的使用</title>
      <link href="/2022/10/17/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/10/17/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>  感觉自己反应总是比别人慢半拍，近段时间也算是通过“一些奇怪的方式”醒悟到学习的重要性，就整理整理这几个渗透工具的使用方式，今天先学习msf（metasploit）工具的一些用法。</p><h2 id="关于msf的一些简单介绍"><a href="#关于msf的一些简单介绍" class="headerlink" title="关于msf的一些简单介绍"></a>关于msf的一些简单介绍</h2><h3 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h3><p>Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。团队合作，在Metasploit和综合报告提出了他们的发现。</p><p>Metasploit自带上百种漏洞，还可以在online exploit building demo（在线漏洞生成演示）上看到如何生成漏洞。这使自己编写漏洞变得更简单，它势必将提升非法shellcode的水平，并且扩大网络阴暗面。与其相似的专业漏洞工具，如Core Impact和Canvas已经被许多专业领域用户使用。Metasploit降低了使用的门槛，将其推广给大众。</p><h3 id="简单安装和更新"><a href="#简单安装和更新" class="headerlink" title="简单安装和更新"></a>简单安装和更新</h3><p>  这里呢，是建议安装在kali上，因为kali本身为linux系统，集合了大量优秀的安全工具，且通过系统指令就可以安装和升级工具.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install metasploit-framework</span><br></pre></td></tr></table></figure><p>  当重新安装完msf报错或不能打开时，依次使用以下三条命令，切记不能偷懒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bundler</span><br><span class="line"><span class="built_in">cd</span> /usr/share/metasploit-framework</span><br><span class="line">sudo bundle install</span><br></pre></td></tr></table></figure><h3 id="msf的一些简单指令"><a href="#msf的一些简单指令" class="headerlink" title="msf的一些简单指令"></a>msf的一些简单指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">msfconsole       进入msf框架</span><br><span class="line">search ms17_010  使用search命令查找相关漏洞</span><br><span class="line">use explpit/windows/smb/ms17_010_etrenalblue  使用use进入模块</span><br><span class="line"><span class="built_in">help</span>/?           帮助菜单</span><br><span class="line"><span class="built_in">exit</span>             退出msf控制台；退出会话</span><br><span class="line">back             退出模块</span><br><span class="line">info             查看模块详细信息</span><br><span class="line"><span class="built_in">set</span>              模块选项设置</span><br><span class="line">show             显示所给类型的模块</span><br><span class="line">show options     查看模块需要配置的参数</span><br><span class="line">show targets     显示适用的payload类型</span><br><span class="line">background       将当前操作在后台运行</span><br><span class="line">use              使用所选择的模块</span><br><span class="line"><span class="built_in">set</span>              设置选项</span><br><span class="line"><span class="built_in">unset</span>            取消设置的选项</span><br><span class="line">run / exploit    启动脚本</span><br></pre></td></tr></table></figure><p>  不同攻击用到的步骤不一样，不是一成不变的，需要灵活运用。<br>  我们也可以将攻击代码写进configure.rc（只要是.rc结尾的文件）配置文件中，然后使用命令msfconsole -r configure.rc进行自动攻击！</p><h2 id="msf的常用模块详解"><a href="#msf的常用模块详解" class="headerlink" title="msf的常用模块详解"></a>msf的常用模块详解</h2><p>  辅助模块（auxiliary）、渗透攻击模块（exoloits）、攻击载荷模块（payloads）、 空指令模块（nops）、 编码器模块（encoders）、后渗透攻击模块（post）、免杀模块（evasion）这七个模块可以完成情报搜集阶段，威胁建模阶段，漏洞分析阶段，渗透攻击阶段，后渗透攻击阶段，报告生成阶段</p><h3 id="通常应用步骤（exoloits）"><a href="#通常应用步骤（exoloits）" class="headerlink" title="通常应用步骤（exoloits）"></a>通常应用步骤（exoloits）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">search 名字    检索系统漏洞</span><br><span class="line">use 控制模块   挑选进攻控制模块</span><br><span class="line">get RHOST ip  设置进攻ip</span><br><span class="line">get RPORT 445 设定进攻端口号</span><br><span class="line">girl payloads 查询能用payloads</span><br><span class="line">get payload windows/meterperter/bind_tcp -设定进攻荷载</span><br><span class="line">get LHOST ip 监视应用程序ip</span><br><span class="line">get LPORT 4444 设定监视的端口号</span><br><span class="line">girl options 查询设定好的主要参数</span><br><span class="line">exploit 进行进攻</span><br><span class="line">info 查询所属控制模块的信息内容</span><br><span class="line">back 撤出当今系统漏洞控制模块，挑选别的的系统漏洞控制模块</span><br><span class="line">exploits：运用漏洞开展进攻</span><br><span class="line">payload：取得成功 exploit 以后，真实在总体目标系统软件实行的编码或命令</span><br><span class="line">connect 用以远程控制连接服务器，通常用以内部网渗入。</span><br><span class="line">connect 192.168.9.1 8080 connect+iP+服务器端口</span><br><span class="line"><span class="built_in">exit</span> 撤出msfconsole的指令。</span><br><span class="line">search 系统漏洞名字 开展系统漏洞控制模块或软件的搜索</span><br></pre></td></tr></table></figure><h2 id="情报搜集"><a href="#情报搜集" class="headerlink" title="情报搜集"></a>情报搜集</h2><h3 id="主机发现使用模块命令"><a href="#主机发现使用模块命令" class="headerlink" title="主机发现使用模块命令"></a>主机发现使用模块命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/discovery/</span><br></pre></td></tr></table></figure><p>  然后tab键补全就可以选择想选的模块</p><p>  可以使用arp_sweep来枚举本地局域网中所有活跃的主机</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>Metasploit的辅助模块中提供了几款实用的端口扫描器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/portscan/*</span><br></pre></td></tr></table></figure><p>一般情况下推荐使用syn端口扫描器，因为它的扫描速度快，结果准确且不易被对方察觉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/portscan/syn</span><br></pre></td></tr></table></figure><h3 id="勘察服务详细信息"><a href="#勘察服务详细信息" class="headerlink" title="勘察服务详细信息"></a>勘察服务详细信息</h3><p> msf中可以调用系统命令  可以sudo nmap</p><h3 id="服务查点"><a href="#服务查点" class="headerlink" title="服务查点"></a>服务查点</h3><p>在Metasploit的辅助模块中，有很多用于服务和查点的工具，这些工具通常以[service_name]_version命名。该模块可用于遍历网络中包含某种服务的主机，并进一步确定服务的版本。</p><h4 id="SSH服务查点"><a href="#SSH服务查点" class="headerlink" title="SSH服务查点"></a>SSH服务查点</h4><p>  通常管理员会使用SSH对服务器进行远程登陆，服务器会向SSH客户端返回一个远程Shell链接。入锅没有做其他的安全增强配置，只要获取服务的登录口令，就可以使用SSH客户端登陆服务器，那就相当于获取了响应登录用户的所有权限。可以使用ssh_version模块遍历网络中开启SSH服务的主机。</p><p>  auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_version</p><h4 id="其他服务查点"><a href="#其他服务查点" class="headerlink" title="其他服务查点"></a>其他服务查点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/mssql/mssql_ping</span><br><span class="line">auxiliary/scanner/telnet/telent_version</span><br><span class="line">auxiliary/scanner/mysql/mysql_version</span><br><span class="line">auxiliary/scanner/ftp/ftp_version</span><br><span class="line">auxiliary/scanner/http/http_version</span><br></pre></td></tr></table></figure><h2 id="口令猜测"><a href="#口令猜测" class="headerlink" title="口令猜测"></a>口令猜测</h2><h3 id="SSH服务口令猜解"><a href="#SSH服务口令猜解" class="headerlink" title="SSH服务口令猜解"></a>SSH服务口令猜解</h3><p>  在确定了网络上的SSH服务后，可以使用MSF中的ssh_login模块对SSH服务进行口令猜测攻击，在进行口令攻击前，需要一个好用的用户名和口令字典。</p><h3 id="口令爆破：SSH"><a href="#口令爆破：SSH" class="headerlink" title="口令爆破：SSH"></a>口令爆破：SSH</h3><p>第一步:选择模块<br>search ssh_login</p><p>auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_login</p><p>（show option）</p><p>第二步：设置<br>set RHOST 192.168.190.131</p><p>set USERname kail</p><p>set PASS_FILE &#x2F;home&#x2F;kali&#x2F;tools&#x2F;wordlist&#x2F;top3000.txt</p><p>#路径为字典位置，这是我自己下载的字典</p><p>run</p><h3 id="其他服务口令猜测"><a href="#其他服务口令猜测" class="headerlink" title="其他服务口令猜测"></a>其他服务口令猜测</h3><p>口令猜解 模块<br>telnet  use auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login<br>mssql    use auxiliary&#x2F;scanner&#x2F;mssql&#x2F;mssql_login<br>smb      use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_login</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞利用exploit，也就是我们常说的exp，就是对漏洞进行攻击的代码。</p><p>1.exploit漏洞利用模块路径（针对不同平台的exploit）<br>&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;exploits</p><p>2.进入Windows平台看看，这里会列出针对Windows平台不同服务的漏洞利用。<br>&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;exploits&#x2F;windows</p><p>3.进入smb服务，这里是windows中经常爆出漏洞的服务，比如我们的永恒之蓝漏洞就在这里面。漏洞利用代码是以rb结尾的文件，因为编写语言为ruby。<br>&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;exploits&#x2F;windows&#x2F;smb</p><h2 id="攻击载荷（payload）"><a href="#攻击载荷（payload）" class="headerlink" title="攻击载荷（payload）"></a>攻击载荷（payload）</h2><h3 id="payload模块路径："><a href="#payload模块路径：" class="headerlink" title="payload模块路径："></a>payload模块路径：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/metasploit-framework/modules/payloads</span><br></pre></td></tr></table></figure><h3 id="Metasploit中的-Payload-模块主要有以下三种类型"><a href="#Metasploit中的-Payload-模块主要有以下三种类型" class="headerlink" title="Metasploit中的 Payload 模块主要有以下三种类型"></a>Metasploit中的 Payload 模块主要有以下三种类型</h3><p>Single：<br>  是一种完全独立的payload，而且使用起来就像是运行calc.exe一样简单，例如添加一个系统用户或者删除一个文件。由于Single Payload是完全独立的，因此它们有可能会被类似nercat这样的非metasploit处理工具所捕捉到。</p><p>Stager：<br>  这种Payload 负责建立目标用户与攻击者之间的网络连接，并下载额外的组件或应用程序。一种常见的Stager Payload就是reverse_tcp，它可以让目标系统与攻击者建立一条 tcp 连接，让目标系统主动连接我们的端口(反向连接)。另一种常见的是bind_tcp，它可以让目标系统开启一个tcp监听器，而攻击者随时可以与目标系统进行通信(正向连接)。</p><p>Stage：<br>  是Stager Payload下的一种Payload组件，这种Payload可以提供更加高级的功能，而且没有大小限制。</p><p>在metasploit中，我们可以通关payload的名称喝使用格式来推断它的类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Single Payload的格式为：</span></span><br><span class="line">&lt;target&gt;/ &lt;single&gt;  如：windows/powershell_bind_tcp</span><br><span class="line"><span class="comment">#Stager/Stage Payload的格式为：</span></span><br><span class="line">&lt;target&gt;/ &lt;stage&gt; / &lt;stager&gt;  如：windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模板</title>
      <link href="/2022/10/14/hello-world/"/>
      <url>/2022/10/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
