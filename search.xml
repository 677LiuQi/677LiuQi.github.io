<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>僵尸进程的创建和杀死</title>
      <link href="/2022/11/03/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/11/03/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>感谢李世斌老师，感谢肖志恒老师，感谢郭晓婉老师提供的指导与帮助。</p><h3 id="vim和gss的下载"><a href="#vim和gss的下载" class="headerlink" title="vim和gss的下载"></a>vim和gss的下载</h3><p>基于Linux系统下的vim和gcc安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim</span><br><span class="line">sudo apt-get install gcc</span><br></pre></td></tr></table></figure><p>输入命令查看gcc是否安装完成，安装完成后会显示版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><h3 id="创建一个-c文件"><a href="#创建一个-c文件" class="headerlink" title="创建一个.c文件"></a>创建一个.c文件</h3><p>在终端输入命令创建c语言文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim xxx.c</span><br></pre></td></tr></table></figure><p>进入编译<br>输入僵尸进程的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">pid_t childpid;</span><br><span class="line">int status;</span><br><span class="line">int retval;</span><br><span class="line">childpid=fork();</span><br><span class="line"><span class="keyword">if</span>(-1==childpid)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(0==childpid)</span><br><span class="line">&#123;</span><br><span class="line">puts(<span class="string">&quot;In child process&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child process ID=%d,this process will sleep 100s\n&quot;</span>,(int) getpid());</span><br><span class="line"><span class="built_in">sleep</span>(100);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent process ID=%d, prarent process will do waitpid\n&quot;</span>,(int)getpid());</span><br><span class="line"><span class="keyword">if</span>(0==(waitpid(childpid,&amp;status,WNOHANG)))</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;kill the active child process\n&quot;</span>);</span><br><span class="line"> retval=<span class="built_in">kill</span>(childpid,SIGKILL);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;parent killed child process\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(retval)</span><br><span class="line"> &#123;</span><br><span class="line"> puts(<span class="string">&quot;kill failed.&quot;</span>);</span><br><span class="line"> perror(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line"> waitpid(childpid,&amp;status,0);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d was killed \n&quot;</span>,childpid);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;current active process after killed child process \n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结束后退出：</p><p>方式一：按下esc键，输入“:wq”3个英文字符，然后按下Enter键，表示保存文件并退出。</p><p>方式二：按下esc键，输入“:q”两个英文字符，然后按下Enter键，表示不保存并退出。（如果本次编辑没有修改内容，则可以顺利退出；否则，vim编辑器是不会允许你退出的，这时如果想要不保存退出，就要使用下面的方法三）</p><p>方式三：按下esc键，输入“:q!”3个英文字符，然后按Enter键，表示不保存并强制退出。</p><h3 id="利用gcc编译文件"><a href="#利用gcc编译文件" class="headerlink" title="利用gcc编译文件"></a>利用gcc编译文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c - o xxx  （xxx为你设置的文件名）</span><br></pre></td></tr></table></figure><h3 id="编译结束后运行文件"><a href="#编译结束后运行文件" class="headerlink" title="编译结束后运行文件"></a>编译结束后运行文件</h3><p>输入命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx   （xxx为你的设置文件名）</span><br></pre></td></tr></table></figure><h3 id="查看僵尸进程pid号"><a href="#查看僵尸进程pid号" class="headerlink" title="查看僵尸进程pid号"></a>查看僵尸进程pid号</h3><p>输入命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep defunct</span><br></pre></td></tr></table></figure><img src="/img/z1.jpg "> <h3 id="利用top查看僵尸进程"><a href="#利用top查看僵尸进程" class="headerlink" title="利用top查看僵尸进程"></a>利用top查看僵尸进程</h3><p>输入命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>如果不出意外，你的页面右上角zombie数量为1 证明僵尸进程存在<br><img src="/img/z2.jpg "> </p><p>如果出了意外，请跳转到文章结尾。</p><p>下一步就到了杀死僵尸进程的时候了！</p><h3 id="如何杀死僵尸进程"><a href="#如何杀死僵尸进程" class="headerlink" title="如何杀死僵尸进程"></a>如何杀死僵尸进程</h3><p>一般僵尸进程很难直接kill掉，不过您可以kill父进程(僵尸父亲)，“父亲”死后，僵尸进程成为”孤儿进程”，接着给init它始终会负责清理僵尸进程．紧随着父亲消失了，儿子也就跟着消失了。</p><h4 id="ps-命令和-grep命令寻找僵尸进程"><a href="#ps-命令和-grep命令寻找僵尸进程" class="headerlink" title="ps 命令和 grep命令寻找僵尸进程"></a>ps 命令和 grep命令寻找僵尸进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -ostat,ppid,pid,cmd | grep -e <span class="string">&#x27;^[Zz]&#x27;</span></span><br></pre></td></tr></table></figure><img src="/img/z3.jpg "> <p>记住你的僵尸pid号</p><h4 id="使用kill命令杀死僵尸进程"><a href="#使用kill命令杀死僵尸进程" class="headerlink" title="使用kill命令杀死僵尸进程"></a>使用kill命令杀死僵尸进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程pid号</span><br></pre></td></tr></table></figure><p>运行结束后可以再次输入top查看进程是否被杀死<br><img src="/img/z4.png "> </p><h3 id="已经编译运行完成为什么zombie数量为0"><a href="#已经编译运行完成为什么zombie数量为0" class="headerlink" title="已经编译运行完成为什么zombie数量为0"></a>已经编译运行完成为什么zombie数量为0</h3><p>此方法来自李世斌老师在某天打完游戏后想出来的野路子。<br>.&#x2F;xxx  运行结束后 直接ctrl+z 再查看top</p><p>输入.&#x2F;之后，子进程正在执行，还没执行到杀死僵尸进程那一步，直接ctrl+z强制退出，所以还没执行到那一步，这个时候查看应该能看到。</p><p>更正规的方法是修改代码，此条解决方案来自肖志恒老师。<br>将倒数第三行的 getchar();删掉，在杀死子进程的那个父进程前面加个sleep。具体等肖老师研究了再说说。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大摆特摆</title>
      <link href="/2022/10/26/%E5%94%A0%E5%94%A0%E5%8F%A8%E5%8F%A8/"/>
      <url>/2022/10/26/%E5%94%A0%E5%94%A0%E5%8F%A8%E5%8F%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="2022年10月26日"><a href="#2022年10月26日" class="headerlink" title="2022年10月26日"></a>2022年10月26日</h2><p>  安装图床失败有感而发呜呜呜呜。这个事情告诉我们，有时候努力不如摆烂。开心的席师傅在配置好gitee的图床的时候，发现它不能用了呜呜呜嘿嘿嘿呜呜呜<br>  事实证明，精神状态差了，人就开心了。<br>  我想了一夜，我都不知道为什么我的token不能用为什么github不能用，为什么别人的界面甚至和我的长得都不一样，紫砂，这个博客里面不会出现照片了。<br>  MS.SM什么垃圾网站都打不开。<br>  因为席师傅安装不好图呜呜呜呜，以后有钱了，再说租服务器的事情。<br>  罢了，人生就是这样，大肠包小肠，小肠包大肠。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课后题</title>
      <link href="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>  操作系统老师布置的一些课后题</p><h2 id="第三章：处理机调度与死锁"><a href="#第三章：处理机调度与死锁" class="headerlink" title="第三章：处理机调度与死锁"></a>第三章：处理机调度与死锁</h2><h3 id="高级调度与低级调度的主要任务是什么-为什么要引入中级调度"><a href="#高级调度与低级调度的主要任务是什么-为什么要引入中级调度" class="headerlink" title="高级调度与低级调度的主要任务是什么? 为什么要引入中级调度?"></a>高级调度与低级调度的主要任务是什么? 为什么要引入中级调度?</h3><p> 高级调度的主要任务：用于决定把外存上处于后背队列中的哪些作业调入内存，并为它们创建进程，分配必要的资源，再将新创建的进程插入就绪队列上，准备执行。低级调度的主要任务：用于决定就绪队列中的哪个进程获得处理机，然后再由分派程序执行将处理机分配给该进程的具体操作。</p><h3 id="引起进程调度的原因"><a href="#引起进程调度的原因" class="headerlink" title="引起进程调度的原因"></a>引起进程调度的原因</h3><p>在不可剥夺方式下的引起进程调度的原因：</p><p>　(1)正在执行的进程执行完毕。这时，如果不选择新的就绪进程执行，将浪费处理机资源。</p><p>　(2)执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等状态。</p><p>　(3)执行中进程调用了P原语操作，从而因资源不足而被阻塞；或调用了v原语操作激活了等待资源的进程队列。</p><p>　(4)执行中进程提出I&#x2F;O请求后被阻塞。</p><p>　(5)在分时系统中时间片已经用完。</p><p>　(6)在执行完系统调用等系统程序后返回用户进程时，这时可看作系统进程执行完毕，从而可调度选择一新的用户进程执行。</p><p>在CPU执行方式是可剥夺时．还有：</p><p>　(7)就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。</p><h3 id="什么是死锁-产生死锁的必要条件-怎样预防和避免死锁"><a href="#什么是死锁-产生死锁的必要条件-怎样预防和避免死锁" class="headerlink" title="什么是死锁? 产生死锁的必要条件?怎样预防和避免死锁?"></a>什么是死锁? 产生死锁的必要条件?怎样预防和避免死锁?</h3><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><p>当多个进程在运行过程中因为争夺资源而造成的一种僵局, 当进程处于这种僵持状态的时候, 若无外力作用, 它们将永远无法向前推进. 这种状态就称为死锁。</p><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><p>产生死锁总共有 4 个必要条件:</p><p>资源互斥: 当一个资源被一个进程使用时候, 其他继承不能使用该资源</p><p>资源不可剥夺: 进程已持有的资源在使用完之前是不可被剥夺的, 只能在使用完后由自己释放</p><p>请求和保持: 当进程在请求其他资源的时候, 对自己已持有的资源保持不放</p><p>循环等待: 即存在一个等待队列: 例如: A 占有 B 的资源, B 占有 C 的资源, C 占有 A 的资源, 这样就形成了一个等待环路。</p><p>当以上 4 个条件同时成立的时候, 就会产生死锁</p><h4 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h4><p>1.资源一次性分配(破坏请求条件): 一次性分配所有的资源, 这样就不会再有请求了</p><p>2.(破坏保持条件): 一个进程只要有一个资源得不到分配, 就也不给这个进程分配其他资源</p><p>3.可剥夺资源(破坏不可剥夺性): 一个进程即使获得了部分资源, 但是如果得不到其他资源, 就需要释放掉已有的资源</p><p>4.资源有序分配(破坏循环等待): 系统为每类资源分配一个编号, 每一个进程按照编号以递增的顺序请求资源, 释放则相反</p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>预防死锁的四种方法, 都会严重的影响系统性能. 因此可以尽可能去避免死锁的产生.<br>在避免死锁的策略中, 允许进程动态地申请资源. 所以, 系统在进行资源分配的时候, 会预先计算资源分配的安全性, 如果此次资源分配不会导致系统进入不安全的状态, 就将资源分配给进程, 否则, 进程等待。</p><p>补充：避免死锁的方法中最经典和最重要的就是: 银行家算法<br>原理:<br>将操作系统视为一个银行家, 将操作系统所管理的资源视为银行家的资金, 进程申请资源就视为用户向银行家贷款<br>当一个顾客对资金的最大需求量不超过银行家现有的资金时, 就可以接纳该顾客<br>顾客可以分期贷款, 但是贷款的总额不可以超过最大需求量<br>当银行家现有资金不能满足用户尚需的贷款金额时, 可以推迟支付贷款, 但是使顾客在有限的时间内拿到贷款<br>当顾客得到所有所需资金后, 一定可以在有限时间内归还所有的资金</p><h4 id="解除死锁的方法"><a href="#解除死锁的方法" class="headerlink" title="解除死锁的方法"></a>解除死锁的方法</h4><p> 剥夺资源: 从其他进程剥夺足够数量的资源给死锁, 用以解除死锁状态<br> 撤销进程: 撤销系统中一个或者多个死锁进程</p><h3 id="一个课后题链接"><a href="#一个课后题链接" class="headerlink" title="一个课后题链接"></a>一个课后题链接</h3><p> 还是白嫖好。<br> <a href="https://blog.csdn.net/m0_50629759/article/details/120927611?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%86%E4%B8%80%E7%BB%84%E8%BF%9B%E7%A8%8B%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB%EF%BC%8C%E5%A6%82%E5%9B%BE3-23%E6%89%80%E7%A4%BA&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120927611.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/m0_50629759/article/details/120927611?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B0%86%E4%B8%80%E7%BB%84%E8%BF%9B%E7%A8%8B%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB%EF%BC%8C%E5%A6%82%E5%9B%BE3-23%E6%89%80%E7%A4%BA&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120927611.nonecase&amp;spm=1018.2226.3001.4187</a></p><h3 id="设系统中有下述解决死锁的办法"><a href="#设系统中有下述解决死锁的办法" class="headerlink" title="设系统中有下述解决死锁的办法"></a>设系统中有下述解决死锁的办法</h3><p>(1)银行家算法。</p><p>(2)检测死锁，终止处于死锁状态的进程，释放该进程所占有的资源。</p><p>(3)资源预分配。</p><p>请问哪种办法允许最大的并发性，即哪种办法允许更多的进程无等待地向前推进?请按“并发性”从大到小对上述三种办法进行排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三种办法中，首先检测死锁允许更多的进程无等待地向前推进。因为该方法允许死锁出现，即允许进程最大限度地申请并分配资源，直至出现死锁，再由系统出面解决。</span><br><span class="line">其次是银行家算法，该方法允许进程自由申请资源，只是在某个进程申请时检查系统是否处于安全状态，若是，则可立即分配，若不是，才拒绝。</span><br><span class="line">最后是资源预分配，因为此方法要求进程在运行之前申请所需的全部资源才可开始运行，这样会使得许多进程因申请不到资源而无法开始，得到资源的进程也并不是同时需要所占的全部资源，因此导致资源的浪费。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java学习</title>
      <link href="/2022/10/21/java/"/>
      <url>/2022/10/21/java/</url>
      
        <content type="html"><![CDATA[<p>  关于java也没有好好学这件事情，真的已经麻了。到CSDN总结了点学习重点，主要是自己打一遍印象深。</p><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="案例常见问题"><a href="#案例常见问题" class="headerlink" title="案例常见问题"></a>案例常见问题</h3><p>1、非法字符问题。Java中的符号都是英文格式的。<br>2、大小写问题。Java语言对大小写敏感(区分大小写)。<br>3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。<br>4、编译命令后的java文件名需要带文件后缀.java<br>5、运行命令后的class文件名(类名)不带文件后缀.class …</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h3><p>单行注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这是单行注释文字</span><br></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  这是多行注释文字 这是多行注释文字 这是多行注释文字</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>多行注释不能嵌套使用</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是在程序运行过程中，其值不可以发生改变的量。</p><p>java中的常量分类</p><p>字符串常量 用双引号括起来的多个字符（可以包含0个，一个，或者多个），，例如”a”、“abc”、”中国”等<br>整数常量整数：-10、0、88等<br>小数常量整数：-5.5、1.0、88.88等<br>字符常量 用单引号括起来的一个字符 :’a’、’5’、’B’、’哈’等<br>布尔常量 布尔值，表示真假，只有两个值true和false<br>空常量 一个特殊的值 ，空值，为null<br>除空常量外，其他常量局可以使用输出语句直接输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println (10); //输出一个字符</span><br><span class="line">    System.out.println (5.5); //输出一个小数</span><br><span class="line">    System.out.println (‘a’)； //输出一个字符</span><br><span class="line">    System.out.println(<span class="literal">true</span>); // 输出boolean值<span class="literal">true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;毛毛摸猫猫&quot;</span>); // 输出字符串</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h3><p>我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位 (bit)”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节(byte)”，<br>通常用大写字母”B”表示，字节是由连续的8个位组成。<br>除了字节外还有一些常用的存储单位，其换算单位如下:<br>1B(字节) &#x3D; 8bit<br>1KB &#x3D; 1024B<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB<br>1TB &#x3D; 1024GB</p><h3 id="Java中的数据类型"><a href="#Java中的数据类型" class="headerlink" title="Java中的数据类型"></a>Java中的数据类型</h3><p>  java是一种强类型语言，java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。</p><h4 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h4><p>  整数类型的关键字：byte       内存占用：1 取值范围：-128到127<br>  整数类型的关键字：short      内存占用：2 取值范围：-32768到32767<br>  整数类型的关键字：int(默认)  内存占用：4 取值范围：-2的31次方到2的31次方-1<br>  整数类型的关键字：long       内存占用：8 取值范围：-2的63次方到2的63次方-1</p><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>  浮点类型的关键字：float       内训占用：4 取值范围：负数:-3.402823E+38到-1.401298E-45 正数: 1.401298E-45到 3.402823E+38<br>  浮点类型的关键字：double(默认) 内存占用：8 取值范围：负数:-1.797693E+308到-4.9000000E-324 正数:4.9000000E-324 到1.797693E+308</p><h4 id="字符类型和布尔类型"><a href="#字符类型和布尔类型" class="headerlink" title="字符类型和布尔类型"></a>字符类型和布尔类型</h4><p>  字符类型的关键字：char内存占用：2取值范围：0-65535<br>  布尔类型关键字：boolean内存占用：1取值范围：true，false</p><p>  说明: e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。在java中整数默认是int类型，浮点数默认是double类型。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><pre><code>在程序运行过程中，其值可以发生改变的量从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化</code></pre><p>变量的定义格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：数据类型 变量名 = 变量值;</span><br><span class="line">范例：   int    a     = 10;</span><br></pre></td></tr></table></figure><p>数据类型 变量名&#x3D;初始化值；&#x2F;&#x2F;生命变量并赋值<br>int age &#x3D; 18；<br>System.out.println(age)</p><p>或者 </p><p>&#x2F;&#x2F;先声明，后赋值（使用前赋值即可）数据类型 变量名;<br>变量名&#x3D;初始化值;<br>double money;<br>money &#x3D; 55.5;<br>System.out.println(money);</p><p>还可以</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于网络安全的常见用语缩写</title>
      <link href="/2022/10/20/%E5%B8%B8%E8%A7%81%E7%94%A8%E8%AF%AD/"/>
      <url>/2022/10/20/%E5%B8%B8%E8%A7%81%E7%94%A8%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>  嘿嘿嘿，我是笨蛋捏。关于学了一年半了还不知道一些缩写的意思，故此篇文章产生！</p><h2 id="亿点点知识补充"><a href="#亿点点知识补充" class="headerlink" title="亿点点知识补充"></a>亿点点知识补充</h2><h3 id="什么是EXP"><a href="#什么是EXP" class="headerlink" title="什么是EXP"></a>什么是EXP</h3><p>EXP全称（exploit）即利用，是指利用系统漏洞进行攻击的动作。</p><p>EXP，Exploit，中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。</p><h3 id="什么是Poc（Proof-of-Concept概念证明）"><a href="#什么是Poc（Proof-of-Concept概念证明）" class="headerlink" title="什么是Poc（Proof of Concept概念证明）"></a>什么是Poc（Proof of Concept概念证明）</h3><p>Poc是用来证明漏洞存在的。简单来说用来证明一段漏洞的代码，他是无害的。</p><h3 id="什么是payload"><a href="#什么是payload" class="headerlink" title="什么是payload"></a>什么是payload</h3><p>payload（有效荷载），指的是exploit执行成功之后，真正在系统进行执行的利用执行的代码或者指令。</p><p>payload是一种以JSON格式进行数据传输的一种方式。</p><p>http可能会传输payload，如果不限制其请求的方式(那么请求的方法就是OPTIONS)或者响应的状态码，其包含元数据，头部区域和数据。</p><p>如果数据是通过正常的put或者post方法发送的，那么payload就是一个http请求起始行紧接一个CRLF后面的那一部分。</p><h3 id="什么是shellcode"><a href="#什么是shellcode" class="headerlink" title="什么是shellcode"></a>什么是shellcode</h3><p>shellcode简单翻译就是shell代码，是payload的一种，他是因为建立正反shell而得名的。shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。</p><h3 id="什么是VUL"><a href="#什么是VUL" class="headerlink" title="什么是VUL"></a>什么是VUL</h3><p>  VUL，Vulnerability的缩写，泛指漏洞。</p><h3 id="CVE漏洞编号"><a href="#CVE漏洞编号" class="headerlink" title="CVE漏洞编号"></a>CVE漏洞编号</h3><p>CVE 的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露，例如CVE-2015-0057、CVE-1999-0001等等。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。如果在一个漏洞报告中指明的一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全问题。</p><h3 id="0DAY漏洞和0DAY攻击"><a href="#0DAY漏洞和0DAY攻击" class="headerlink" title="0DAY漏洞和0DAY攻击"></a>0DAY漏洞和0DAY攻击</h3><p>在计算机领域中，零日漏洞或零时差漏洞（英语：Zero-dayexploit）通常是指还没有补丁的安全漏洞，而零日攻击或零时差攻击（英语：Zero-dayattack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。零日漏洞的利用程序对网络安全具有巨大威胁，因此零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。</p><p>零日漏洞及其利用代码不仅对犯罪黑客而言，具有极高的利用价值，一些国家间谍和网军部队，例如美国国家安全局和美国网战司令部也非常重视这些信息。据路透社报告称美国政府是零日漏洞黑市的最大买家。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit的使用</title>
      <link href="/2022/10/17/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/10/17/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<hr><p>  感觉自己反应总是比别人慢半拍，近段时间也算是通过“一些奇怪的方式”醒悟到学习的重要性，就整理整理这几个渗透工具的使用方式，今天先学习msf（metasploit）工具的一些用法。</p><h2 id="关于msf的一些简单介绍"><a href="#关于msf的一些简单介绍" class="headerlink" title="关于msf的一些简单介绍"></a>关于msf的一些简单介绍</h2><h3 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h3><p>Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。团队合作，在Metasploit和综合报告提出了他们的发现。</p><p>Metasploit自带上百种漏洞，还可以在online exploit building demo（在线漏洞生成演示）上看到如何生成漏洞。这使自己编写漏洞变得更简单，它势必将提升非法shellcode的水平，并且扩大网络阴暗面。与其相似的专业漏洞工具，如Core Impact和Canvas已经被许多专业领域用户使用。Metasploit降低了使用的门槛，将其推广给大众。</p><h3 id="简单安装和更新"><a href="#简单安装和更新" class="headerlink" title="简单安装和更新"></a>简单安装和更新</h3><p>  这里呢，是建议安装在kali上，因为kali本身为linux系统，集合了大量优秀的安全工具，且通过系统指令就可以安装和升级工具.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install metasploit-framework</span><br></pre></td></tr></table></figure><p>  当重新安装完msf报错或不能打开时，依次使用以下三条命令，切记不能偷懒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bundler</span><br><span class="line"><span class="built_in">cd</span> /usr/share/metasploit-framework</span><br><span class="line">sudo bundle install</span><br></pre></td></tr></table></figure><h3 id="msf的一些简单指令"><a href="#msf的一些简单指令" class="headerlink" title="msf的一些简单指令"></a>msf的一些简单指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">msfconsole       进入msf框架</span><br><span class="line">search ms17_010  使用search命令查找相关漏洞</span><br><span class="line">use explpit/windows/smb/ms17_010_etrenalblue  使用use进入模块</span><br><span class="line"><span class="built_in">help</span>/?           帮助菜单</span><br><span class="line"><span class="built_in">exit</span>             退出msf控制台；退出会话</span><br><span class="line">back             退出模块</span><br><span class="line">info             查看模块详细信息</span><br><span class="line"><span class="built_in">set</span>              模块选项设置</span><br><span class="line">show             显示所给类型的模块</span><br><span class="line">show options     查看模块需要配置的参数</span><br><span class="line">show targets     显示适用的payload类型</span><br><span class="line">background       将当前操作在后台运行</span><br><span class="line">use              使用所选择的模块</span><br><span class="line"><span class="built_in">set</span>              设置选项</span><br><span class="line"><span class="built_in">unset</span>            取消设置的选项</span><br><span class="line">run / exploit    启动脚本</span><br></pre></td></tr></table></figure><h2 id="msf的常用模块详解"><a href="#msf的常用模块详解" class="headerlink" title="msf的常用模块详解"></a>msf的常用模块详解</h2><p>  辅助模块（auxiliary）、渗透攻击模块（exoloits）、攻击载荷模块（payloads）、 空指令模块（nops）、 编码器模块（encoders）、后渗透攻击模块（post）、免杀模块（evasion）这七个模块可以完成情报搜集阶段，威胁建模阶段，漏洞分析阶段，渗透攻击阶段，后渗透攻击阶段，报告生成阶段</p><h3 id="通常应用步骤（exoloits）"><a href="#通常应用步骤（exoloits）" class="headerlink" title="通常应用步骤（exoloits）"></a>通常应用步骤（exoloits）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">search 名字    检索系统漏洞</span><br><span class="line">use 控制模块   挑选进攻控制模块</span><br><span class="line">get RHOST ip  设置进攻ip</span><br><span class="line">get RPORT 445 设定进攻端口号</span><br><span class="line">girl payloads 查询能用payloads</span><br><span class="line">get payload windows/meterperter/bind_tcp -设定进攻荷载</span><br><span class="line">get LHOST ip 监视应用程序ip</span><br><span class="line">get LPORT 4444 设定监视的端口号</span><br><span class="line">girl options 查询设定好的主要参数</span><br><span class="line">exploit 进行进攻</span><br><span class="line">info 查询所属控制模块的信息内容</span><br><span class="line">back 撤出当今系统漏洞控制模块，挑选别的的系统漏洞控制模块</span><br><span class="line">exploits：运用漏洞开展进攻</span><br><span class="line">payload：取得成功 exploit 以后，真实在总体目标系统软件实行的编码或命令</span><br><span class="line">connect 用以远程控制连接服务器，通常用以内部网渗入。</span><br><span class="line">connect 192.168.9.1 8080 connect+iP+服务器端口</span><br><span class="line"><span class="built_in">exit</span> 撤出msfconsole的指令。</span><br><span class="line">search 系统漏洞名字 开展系统漏洞控制模块或软件的搜索</span><br></pre></td></tr></table></figure><h2 id="情报搜集"><a href="#情报搜集" class="headerlink" title="情报搜集"></a>情报搜集</h2><h3 id="主机发现使用模块命令"><a href="#主机发现使用模块命令" class="headerlink" title="主机发现使用模块命令"></a>主机发现使用模块命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/discovery/</span><br></pre></td></tr></table></figure><p>  然后tab键补全就可以选择想选的模块</p><p>  可以使用arp_sweep来枚举本地局域网中所有活跃的主机</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>Metasploit的辅助模块中提供了几款实用的端口扫描器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/portscan/*</span><br></pre></td></tr></table></figure><p>一般情况下推荐使用syn端口扫描器，因为它的扫描速度快，结果准确且不易被对方察觉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/portscan/syn</span><br></pre></td></tr></table></figure><h3 id="勘察服务详细信息"><a href="#勘察服务详细信息" class="headerlink" title="勘察服务详细信息"></a>勘察服务详细信息</h3><p> msf中可以调用系统命令  可以sudo nmap</p><h3 id="服务查点"><a href="#服务查点" class="headerlink" title="服务查点"></a>服务查点</h3><p>在Metasploit的辅助模块中，有很多用于服务和查点的工具，这些工具通常以[service_name]_version命名。该模块可用于遍历网络中包含某种服务的主机，并进一步确定服务的版本。</p><h4 id="SSH服务查点"><a href="#SSH服务查点" class="headerlink" title="SSH服务查点"></a>SSH服务查点</h4><p>  通常管理员会使用SSH对服务器进行远程登陆，服务器会向SSH客户端返回一个远程Shell链接。入锅没有做其他的安全增强配置，只要获取服务的登录口令，就可以使用SSH客户端登陆服务器，那就相当于获取了响应登录用户的所有权限。可以使用ssh_version模块遍历网络中开启SSH服务的主机。</p><p>  auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_version</p><h4 id="其他服务查点"><a href="#其他服务查点" class="headerlink" title="其他服务查点"></a>其他服务查点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/mssql/mssql_ping</span><br><span class="line">auxiliary/scanner/telnet/telent_version</span><br><span class="line">auxiliary/scanner/mysql/mysql_version</span><br><span class="line">auxiliary/scanner/ftp/ftp_version</span><br><span class="line">auxiliary/scanner/http/http_version</span><br></pre></td></tr></table></figure><h2 id="口令猜测"><a href="#口令猜测" class="headerlink" title="口令猜测"></a>口令猜测</h2><h3 id="SSH服务口令猜解"><a href="#SSH服务口令猜解" class="headerlink" title="SSH服务口令猜解"></a>SSH服务口令猜解</h3><p>  在确定了网络上的SSH服务后，可以使用MSF中的ssh_login模块对SSH服务进行口令猜测攻击，在进行口令攻击前，需要一个好用的用户名和口令字典。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模板</title>
      <link href="/2022/10/14/hello-world/"/>
      <url>/2022/10/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
